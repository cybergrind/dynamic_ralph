"""Agent backend abstraction layer.

Defines the ``AgentBackend`` protocol and ``AgentEvent`` dataclass that
decouple the orchestrator from any specific coding-agent CLI (Claude Code,
Aider, Codex, etc.).

Backends are selected via the ``RALPH_AGENT_BACKEND`` environment variable
(default: ``claude-code``).
"""

from __future__ import annotations

import os
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Iterator, Protocol, runtime_checkable


if TYPE_CHECKING:
    pass


# ---------------------------------------------------------------------------
# AgentEvent — unified streaming event
# ---------------------------------------------------------------------------


@dataclass
class AgentEvent:
    """A single event emitted by an agent backend during execution.

    This is the backend-agnostic representation of streaming output.  Each
    backend is responsible for converting its native event format into
    ``AgentEvent`` instances.

    Attributes:
        kind: Semantic event category.  One of:

            * ``"system"``     - session/model metadata
            * ``"assistant"``  - text generated by the agent
            * ``"tool_use"``   - the agent is invoking a tool
            * ``"tool_result"``- output returned from a tool invocation
            * ``"result"``     - terminal event with cost/token metrics
            * ``"error"``      - non-fatal error or warning
            * ``"raw"``        - opaque/unparseable line (logged as-is)

        text: Human-readable representation of the event (for display).
        raw:  The original, unparsed payload (e.g. a JSON dict) for
              logging and downstream metric extraction.
    """

    kind: str
    text: str = ''
    raw: dict = field(default_factory=dict)


# ---------------------------------------------------------------------------
# AgentResult — unified result of an agent invocation
# ---------------------------------------------------------------------------


@dataclass
class AgentResult:
    """Captures all outputs from an agent invocation.

    This is intentionally a plain dataclass (not Pydantic) so it stays
    lightweight and can be constructed incrementally as events stream in.
    """

    exit_code: int = 1
    num_turns: int = 0
    cost_usd: float = 0.0
    input_tokens: int = 0
    output_tokens: int = 0
    completion_status: str = 'unknown'
    final_response: str = ''
    timed_out: bool = False


# ---------------------------------------------------------------------------
# AgentBackend protocol
# ---------------------------------------------------------------------------


@runtime_checkable
class AgentBackend(Protocol):
    """Protocol that every agent backend must satisfy.

    A backend knows how to:

    1. **build a command** (``build_command``) - return the argv list for
       the agent process, given a prompt and optional constraints.
    2. **wrap in Docker** (``build_docker_command``) - prepend Docker args
       when running outside a container.
    3. **parse events** (``parse_events``) - convert raw stdout lines into
       ``AgentEvent`` objects.
    4. **extract result** (``extract_result``) - pull cost/token/status
       metrics from the stream of ``AgentEvent``s and produce an
       ``AgentResult``.
    """

    def build_command(
        self,
        prompt: str,
        *,
        system_prompt: str = '',
        max_turns: int | None = None,
    ) -> list[str]:
        """Return the command-line argv for a direct (non-Docker) invocation."""
        ...

    def build_docker_command(
        self,
        base_cmd: list[str],
        *,
        agent_id: int,
        workspace: str,
    ) -> list[str]:
        """Wrap *base_cmd* in a ``docker run`` invocation.

        Parameters:
            base_cmd:  The argv returned by :meth:`build_command`.
            agent_id:  Numeric agent identifier (used for namespacing).
            workspace: Absolute path to the host workspace directory.

        Returns:
            The full ``docker run … <image> <base_cmd>`` argv list.
        """
        ...

    def parse_events(self, lines: Iterator[str]) -> Iterator[AgentEvent]:
        """Parse raw stdout lines into :class:`AgentEvent` objects.

        This is a streaming generator: it yields events as they are parsed
        from *lines*, which is itself an iterator over the process stdout.
        """
        ...

    def extract_result(self, events: list[AgentEvent], exit_code: int) -> AgentResult:
        """Build an :class:`AgentResult` from the collected events.

        Called after the agent process has exited.  *events* contains every
        ``AgentEvent`` yielded during the run; *exit_code* is the process
        return code.
        """
        ...


# ---------------------------------------------------------------------------
# Backend registry / factory
# ---------------------------------------------------------------------------

_BACKEND_REGISTRY: dict[str, type[AgentBackend]] = {}


def register_backend(name: str, cls: type[AgentBackend]) -> None:
    """Register a backend class under *name*."""
    _BACKEND_REGISTRY[name] = cls


def get_backend(name: str | None = None) -> AgentBackend:
    """Return an instance of the requested backend.

    When *name* is ``None``, falls back to the ``RALPH_AGENT_BACKEND``
    environment variable (default ``"claude-code"``).
    """
    if name is None:
        name = os.environ.get('RALPH_AGENT_BACKEND', 'claude-code')

    if name not in _BACKEND_REGISTRY:
        # Lazy-import built-in backends so the registry is populated on first use
        if name == 'claude-code':
            from multi_agent.backends.claude_code import ClaudeCodeBackend

            register_backend('claude-code', ClaudeCodeBackend)
        else:
            available = ', '.join(sorted(_BACKEND_REGISTRY)) or '(none)'
            msg = f'Unknown agent backend {name!r}. Available: {available}'
            raise ValueError(msg)

    return _BACKEND_REGISTRY[name]()
